---
title: "Supplementary Documentation: Prediction of Infliximab Loss of Response or Adverse Event in a National Cohort of Patients with IBD: Comparison of Traditional and Machine Learning Models"
author: "Jason K. Hou, Tiffany M. Tang, Shubhada Sansgiry, Tony Van, Peter Richardson, Codey Pham, Francessca Cunningham, Jessica A. Baker, Ji Zhu, Akbar K. Waljee"
date: "`r Sys.Date()`"
output: 
  vthemes::vmodern:
    number_sections: true
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
options(width = 10000)
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  cache = FALSE,
  fig.align = "center",
  fig.pos = "H",
  fig.height = 12,
  fig.width = 10
)

FUNCTIONS_DIR <- here::here("functions")
for (fname in list.files(FUNCTIONS_DIR, pattern = "\\.R$", full.names = TRUE)) {
  source(fname, chdir = TRUE)
}

subchunk_idx <- 1
panel_class <- "panel panel-default"
padded_panel_class <- "panel panel-default padded-panel"
fig_width <- 10
fig_height <- 8

DATA_DIR <- here::here("data")
RESULTS_DIR <- here::here("results")
SURV_RESULTS_DIR <- here::here(RESULTS_DIR, "survival_models")
CLASS_RESULTS_DIR <- here::here(RESULTS_DIR, "classification_models")
FIGURES_DIR <- here::here(RESULTS_DIR, "paper_figures")
```

```{css}
.title {
  font-size: 24pt !important;
}
```

```{r helper-funs}
rename_survival_methods <- function(x) {
  dplyr::case_when(
    x == "ltrc" ~ "LTRC RF",
    x == "cox" ~ "Cox",
    x == "cox_lasso" ~ "Cox + Lasso",
    x == "cox_ridge" ~ "Cox + Ridge"
  ) |>
    factor(levels = c("LTRC RF", "Cox + Lasso", "Cox + Ridge", "Cox"))
}

rename_classification_methods <- function(x) {
  dplyr::case_when(
    x == "autogluon_medium" ~ "Autogluon",
    x == "elnet" ~ "Elastic Net",
    x == "gb" ~ "GBDT",
    x == "lasso" ~ "Lasso",
    x == "logistic" ~ "Logistic",
    x == "randf" ~ "RF",
    x == "rfplus" ~ "RF+",
    x == "ridge" ~ "Ridge",
    TRUE ~ x
  ) |>
    factor(
      levels = c(
        "RF+", "RF", "GBDT", 
        "Lasso", "Ridge", "Elastic Net", "Logistic", "Autogluon"
      )
    )
}

rename_varset_modes <- function(x) {
  dplyr::case_when(
    x == "no_labs" ~ "No Lab Info",
    x == "recent_labs" ~ "Recent Labs Only",
    x == "recent_mean_max_labs" ~ "Mean, Max, Recent Labs Only",
    x == "recent_mean_max_recentolsslope_labs" ~ "Mean, Max, Slope, Recent Labs Only",
    x == "recent_accrual_labs" ~ "All Lab Info",
    TRUE ~ x
  ) |>
    factor(
      levels = c(
        "Mean, Max, Recent Labs Only",
        "Mean, Max, Slope, Recent Labs Only",
        "Recent Labs Only",
        "All Lab Info",
        "No Lab Info"
      )
    )
}

rename_variables <- function(x) {
  x <- stringr::str_remove(x, "\\.") |>
    stringr::str_replace_all("_", " ") |>
    stringr::str_remove("lab value ") |>
    stringr::str_remove("accrual ")
  x <- dplyr::case_when(
    x == "n flares preifx" ~ "# Flares Pre-IFX",
    x == "n prior flare" ~ "# Prior Flares",
    x == "count anyenc" ~ "# Any Encounters",
    x == "count IBDenc" ~ "# IBD Encounters",
    stringr::str_detect(x, "hgb") ~ 
      stringr::str_replace(x, "hgb", "Hemoglobin") |>
      stringr::str_to_title(),
    stringr::str_detect(x, "wbc") ~ 
      stringr::str_replace(x, "wbc", "White Blood Cells") |>
      stringr::str_to_title(),
    x == "treatment" ~ "Biosimilar Switch",
    x == "treatmentbiosimilar" ~ "Biosimilar Switch",
    x == "TimeYrs IBD IFX" ~ "IBD Duration",
    x == "priority" ~ "Enrollment Priority",
    x == "concomitant med" ~ "Concomitant Medications",
    x == "Age IFX" ~ "Age at IFX Index",
    stringr::str_detect(x, "co2") ~ 
      stringr::str_to_title(x) |>
      stringr::str_replace("Co2", "CO2"),
    stringr::str_detect(x, "rurality") ~ "Rurality",
    stringr::str_detect(x, "GenderF") ~ "Gender",
    stringr::str_detect(x, "Ethnicity$") ~ "Ethnicity",
    stringr::str_detect(x, "priority") ~ "Enrollment Priority",
    stringr::str_detect(x, "ProviderType gp") ~ "Provider Type",
    stringr::str_detect(x, "IBD type c") ~ "IBD Type",
    stringr::str_detect(x, "race gp$") ~ 
      stringr::str_replace(x, "race gp", "Race"),
    stringr::str_detect(x, "MS cat$") ~ 
      stringr::str_replace(x, "MS cat", "Marital Status"),
    stringr::str_detect(x, "COMORBIDITY cat$") ~ 
      stringr::str_replace(x, "COMORBIDITY cat", "Comorbidity"),
    stringr::str_detect(x, "Ethnicity") ~ 
      stringr::str_replace(x, "Ethnicity", "Ethnicity: ") |>
      stringr::str_to_title(),
    stringr::str_detect(x, "race gp") ~ 
      stringr::str_replace(x, "race gp", "Race: ") |>
      stringr::str_to_title(),
    stringr::str_detect(x, "MS cat") ~ 
      stringr::str_replace(x, "MS cat", "Marital Status: ") |>
      stringr::str_to_title(),
    stringr::str_detect(x, "COMORBIDITY cat") ~ 
      stringr::str_replace(x, "COMORBIDITY cat", "Comorbidity: ") |>
      stringr::str_to_title(),
    TRUE ~ stringr::str_to_title(x)
  )
  return(x)
}

load_classification_results <- function(valid_fname = NULL, test_fname = NULL) {
  valid_df <- NULL
  test_df <- NULL
  if (!is.null(valid_fname)) {
    valid_df <- data.table::fread(
      file.path(CLASS_RESULTS_DIR, valid_fname)
    ) |>
      dplyr::mutate(
        split_mode = "validation"
      )
  }
  if (!is.null(test_fname)) {
    test_df <- data.table::fread(
      file.path(CLASS_RESULTS_DIR, test_fname)
    ) |>
      dplyr::mutate(
        split_mode = "test"
      )
  }
  results_df <- dplyr::bind_rows(valid_df, test_df) |>
    tibble::as_tibble() |>
    dplyr::mutate(
      accrual_name = sprintf("Accrual = %s year", accrual) |>
        forcats::fct_inorder(),
      forecast_name = sprintf("Forecast = %s months", forecast) |>
        forcats::fct_inorder(),
      method = rename_classification_methods(method),
      varset_mode = rename_varset_modes(varset_mode)
    )
  return(results_df)
}

```


# Overview {.tabset .tabset-vmodern}

<div class="panel panel-default padded-panel">
In [@hou2025prediction](), we investigated the safety and effectiveness of non-medical biosimilar switch of Infliximab (IFX), a highly effective and cost effective treatment for Crohn's disease (CD) and ulcerative colitis (UC), and we developed various statistical and machine learning models to predict adverse clinical events among patients on maintenance IFX. In this supplementary documentation, we expand upon our data-driven analyses, providing additional exploratory data analysis, results, and most importantly, justification for the many decisions and judgment calls that are inevitably made throughout any data analysis pipeline as we strive towards more veridical (truthful) data science [@yu2020veridical].
</div>

# Exploratory Data Analysis {.tabset .tabset-vmodern}

<div class="panel panel-default padded-panel">
To begin, we provide an overarching summary of the various sources of data used in our analyses, namely, the IBD-related flares, patient demographics and clinical data, and laboratory values.
Our study population was all Veterans with IFX encounter between January 1, 2017 through September 30, 2020. We retained patients who had not received any biosimilar prior to study start date, and had received an IFX originator (Remicade) maintenance infusion on or after January 1, 2017, leading to a final analytic cohort of 2,591 patients.
</div>

```{r load-data}
patient_df_orig <- load_patient_data()
flares_df_orig <- load_flares_data()
lab_df_orig <- load_lab_data()
```

```{r clean-data}
patient_df <- clean_patient_data(patient_df_orig)
flares_df <- clean_flares_data(flares_df_orig)
flares_df_all <- clean_flares_data(flares_df_orig, mode = "all")
merged_df <- merge_data(patient_df, flares_df)
lab_df_wide <- clean_lab_data(lab_df_orig, patient_df, summarize = TRUE)
```

## Flares Data {.unnumbered .tabset .tabset-pills .tabset-square}

<div class="panel panel-default padded-panel">
The primary outcome of interest in this study is an IBD-related flare.
We define an IBD-related flare as any inpatient hospital visit or outpatient emergency room or urgent care visit associated with Crohnâ€™s disease (CD, 444.x/K50) or ulcerative colitis (UC, 556.x/K51) by admitting ICD9/10 codes.
Below, we provide an overview of all IBD-related flares that occurred in our study population.
</div>

### Overview {.unnumbered}

```{r flares-overview, results ="asis", eval = TRUE}
keep_vars <- c(
  "ID" = "deId",
  "Flare Date" = "event_date",
  "Flare Type" = "event_type",
  "Disease Type" = "disease_type",
  "Is First Flare" = "first"
)
flares_skim_df <- flares_df_all |>
  dplyr::mutate(
    event_type = as.factor(event_type),
    disease_type = as.factor(disease_type)
  ) |>
  dplyr::select(tidyselect::all_of(keep_vars))
skimr::skim(flares_skim_df)
```

### Distribution of Flares {.unnumbered}

<div class="panel panel-default padded-panel">

```{r flares-distribution-summary, results = "asis", eval = TRUE}
cat(
  sprintf("Number of total patients: %s\n\n", nrow(patient_df_orig))
)
cat(
  sprintf(
    "Number of patients who flared at least once: %s\n\n", sum(flares_df$first)
  )
)
cat(
  sprintf(
    "%% of patients who flared at least once: %.1f%%\n\n", 
    sum(flares_df_all$first) / nrow(patient_df_orig) * 100
  )
)
cat(
  sprintf(
    "Distribution of hospital vs ER visits: %.1f%% vs %.1f%%\n\n", 
    mean(flares_df_all$event_type == "hosp") * 100,
    mean(flares_df_all$event_type == "er") * 100
  )
)
cat(
  sprintf(
    "Distribution of Crohn's vs UC flares: %.1f%% vs %.1f%%\n\n", 
    mean(flares_df_all$disease_type == "CR") * 100,
    mean(flares_df_all$disease_type == "UC") * 100
  )
)
```
</div>

```{r flares-distribution, results = "asis", eval = TRUE}
plt <- flares_df_all |>
  dplyr::group_by(deId) |>
  dplyr::summarise(num_flares = dplyr::n()) |>
  ggplot2::ggplot() +
  ggplot2::aes(x = num_flares) +
  ggplot2::geom_bar(fill = "#6FBBE3", stat = "count") +
  ggplot2::labs(
    x = "Number of Flares Per Patient", y = "Number of Patients"
  ) +
  vthemes::theme_vmodern(size_preset = "medium")
vthemes::subchunkify(
  plotly::ggplotly(plt), i = subchunk_idx, add_class = padded_panel_class,
  fig_width = fig_width, fig_height = fig_height,
  caption = "'Distribution of the total number of flares experienced by each patient (excluding the flare-free patients).'"
)
subchunk_idx <- subchunk_idx + 1
```

```{r flares-dates-distribution, results = "asis", eval = TRUE}
plt <- flares_df |>
  dplyr::mutate(
    event_date = event_date / 365.25
  ) |>
  ggplot2::ggplot() +
  ggplot2::aes(x = event_date) +
  ggplot2::geom_histogram(fill = "#6FBBE3", color = "grey98", binwidth = 0.25) +
  ggplot2::labs(
    x = "Time of First Flare (yrs)", y = "Frequency"
  ) +
  vthemes::theme_vmodern(size_preset = "medium")
vthemes::subchunkify(
  plt, i = subchunk_idx, add_class = panel_class,
  fig_width = fig_width, fig_height = fig_height,
  caption = "'Distribution of the time (in years) from the index date of the first flare experienced by each patient.'"
)
subchunk_idx <- subchunk_idx + 1
```

## Patient Data {.unnumbered .tabset .tabset-pills .tabset-square}

<div class="panel panel-default padded-panel">
We used various patient demographic and clinical variables to predict IBD-related flares among patients on maintenance IFX. 
These variables included age at index date, sex, race, Hispanic ethnicity, marital status, rural/urban status, enrollment priority, IBD duration (time from IBD diagnosis to IFX index date), the Charlson Comorbidity score at index (number of comorbidities), concomitant medications (either thiopurine or ASA within the 3 month prior to index), IBD type (CD or UC/IBDU), provider type (allopathic/osteopathic physicians or physician assistants/nursing provider), the number of IBD-specific encounters (including inpatient and outpatient IBD visits), the number of all encounters (including all inpatient and outpatient visits) occurring in the one-year period prior to IFX index, and the number of flares that occurred within one year prior to the index date.
We also included a binary switch predictor variable, indicating whether the patient was switched from the Originator to a Biosimilar prior to prediction time. A switch was defined by two occurrences of Biosimilar within three consecutive IFX medication fills post index. 
These variables were selected a priori based on prior work, biological plausibility, and expert clinician opinion [@beste2021adapted].
Below, we provide an overview of each of these variables and their distributions in our study population.
Note that because of the highly right-skewed distribution of the number of IBD/all encounters, we log-transformed these variables for our analyses.
</div>

### Overview {.unnumbered}

```{r patient-overview, results ="asis", eval = TRUE}
keep_vars <- c(
  "ID" = "deId",
  "Switch" = "switch_factor", 
  "Switch Date" = "newindexswitch_date",
  "Death Date" = "Date_Death",
  "Days to Death/EOS" = "days_to_death_or_end2021",
  "Comorbidity" = "COMORBIDITY_cat",
  "Age at IFX Index" = "Age_IFX", 
  "Gender" = "Gender", 
  "Race" = "race_gp",
  "Ethnicity" = "Ethnicity",
  "Marital Status" = "MS_cat", 
  "Enrollment Priority" = "priority",
  "Concomitant Medications" = "concomitant_med", 
  "IBD Duration" = "TimeYrs_IBD_IFX",
  "IBD Type" = "IBD_type_c", 
  "Rurality" = "rurality",
  "# Any Encounters" = "rawcount_anyenc", 
  "# IBD Encounters" = "rawcount_IBDenc", 
  "Provider Type" = "ProviderType_gp",
  "# Prior Flares" = "n_flares_preifx"
)
patient_skim_df <- patient_df |>
  dplyr::select(tidyselect::all_of(keep_vars))
skimr::skim(patient_skim_df)
```

### Switch {.unnumbered}

<div class="panel panel-default padded-panel">

```{r switch-overview, results = "asis", eval = TRUE}
cat(
  sprintf("Number of total patients: %s\n\n", nrow(merged_df))
)
cat(
  sprintf(
    "Number of patients who switched from Originator to Biosimilar: %s\n\n",
    sum(merged_df$switch)
  )
)
cat(
  sprintf(
    "%% of patients who switched from Originator to Biosimilar: %.1f%%\n\n", 
    sum(merged_df$switch) / nrow(merged_df) * 100
  )
)
```

</div>

```{r switch-dates, results = "asis", eval = TRUE}
plt <- merged_df |>
  dplyr::mutate(
    newindexswitch_date = newindexswitch_date / 365.25
  ) |>
  ggplot2::ggplot() +
  ggplot2::aes(x = newindexswitch_date) +
  ggplot2::geom_histogram(fill = "#6FBBE3", color = "grey98", binwidth = 0.25) +
  ggplot2::labs(
    x = "Time of Switch (yrs)", y = "Frequency"
  ) +
  vthemes::theme_vmodern(size_preset = "medium")
vthemes::subchunkify(
  plt, i = subchunk_idx, add_class = panel_class,
  fig_width = fig_width, fig_height = fig_height,
  caption = "'Distribution of the time (in years) from the index date when patients switched from the Originator to Biosimilar (ignoring patients who did not switch at all).'"
)
subchunk_idx <- subchunk_idx + 1
```


### Covariate Distributions {.unnumbered}

```{r patient-covariates-numeric, results = "asis", eval = TRUE}
num_vars <- c(
  "Age at IFX Index" = "Age_IFX", 
  "IBD Duration" = "TimeYrs_IBD_IFX",
  "log(# Any Encounters + 1)" = "count_anyenc", 
  "log(# IBD Encounters + 1)" = "count_IBDenc",
  "# Prior Flares" = "n_flares_preifx"
)

for (varname in names(num_vars)) {
  var <- num_vars[[varname]]
  plt <- patient_df |>
    ggplot2::ggplot() +
    ggplot2::aes(x = !!rlang::sym(var)) +
    ggplot2::geom_density(fill = "#6FBBE3", alpha = 0.4) +
    ggplot2::labs(
      x = varname, y = "Density", title = "Full Distribution"
    ) +
    vthemes::theme_vmodern(size_preset = "medium")
  plt_by_flare <- merged_df |>
    ggplot2::ggplot() +
    ggplot2::aes(x = !!rlang::sym(var), fill = event) +
    ggplot2::geom_density(alpha = 0.4) +
    ggplot2::labs(
      x = varname, y = "Density", fill = "Flare", title = "By Flare Status"
    ) +
    vthemes::theme_vmodern(size_preset = "medium")
  plt_by_switch <- merged_df |>
    ggplot2::ggplot() +
    ggplot2::aes(x = !!rlang::sym(var), fill = switch_factor) +
    ggplot2::geom_density(alpha = 0.4) +
    ggplot2::labs(
      x = varname, y = "Density", fill = "Switch", title = "By Switch Status"
    ) +
    vthemes::scale_fill_vmodern(discrete = TRUE) +
    vthemes::theme_vmodern(size_preset = "medium")
  plt <- patchwork::wrap_plots(plt, plt_by_flare, plt_by_switch, ncol = 3)
  vthemes::subchunkify(
    plt, i = subchunk_idx, add_class = panel_class,
    fig_width = fig_width * 1.5, fig_height = 5,
    caption = sprintf(
      "'Distribution of %s across all patients (left), stratified by whether or not the patient flared (middle), and stratified by whether or not the patient switched from Originator to Biosimilar (right).'", varname
    )
  )
  subchunk_idx <- subchunk_idx + 1
}
```

```{r patient-covariates-cat, results = "asis", eval = TRUE}
cat_vars <- c(
  "Comorbidity" = "COMORBIDITY_cat",
  "Gender" = "Gender", 
  "Ethnicity" = "Ethnicity",
  "Race" = "race_gp",
  "Marital Status" = "MS_cat", 
  "Enrollment Priority" = "priority",
  "Concomitant Medications" = "concomitant_med", 
  "IBD Type" = "IBD_type_c", 
  "Rurality" = "rurality",
  "Provider Type" = "ProviderType_gp"
)

for (varname in names(cat_vars)) {
  tab <- merged_df |>
    dplyr::group_by(dplyr::across(tidyselect::all_of(cat_vars[varname]))) |>
    dplyr::summarise(
      All = sprintf(
        "%s (%.1f%%)", dplyr::n(), dplyr::n() / nrow(merged_df) * 100
      ),
      `Flare Patients` = sprintf(
        "%s (%.1f%%)", sum(event), sum(event) / sum(merged_df$event) * 100
      ),
      `Flare-free Patients` =sprintf(
        "%s (%.1f%%)", sum(!event), sum(!event) / sum(!merged_df$event) * 100
      ),
      `Switch Patients` = sprintf(
        "%s (%.1f%%)", sum(switch), sum(switch) / sum(merged_df$switch) * 100
      ),
      `Non-switch Patients` = sprintf(
        "%s (%.1f%%)", sum(!switch), sum(!switch) / sum(!merged_df$switch) * 100
      )
    )
  tab |>
    vthemes::pretty_DT(
      rownames = FALSE, options = list(dom = "t", ordering = FALSE)
    ) |>
    vthemes::subchunkify(
      i = subchunk_idx, add_class = padded_panel_class,
      caption = sprintf(
        "'Distribution of %s across all patients (2nd column), stratified by whether or not the patient flared (3rd and 4th columns), and stratified by whether or not the patient switched from Originator to Biosimilar (5th and 6th columns).'", varname
      )
    )
  subchunk_idx <- subchunk_idx + 1
}
```


## Lab Data {.unnumbered .tabset .tabset-pills .tabset-square}

<div class="panel panel-default padded-panel">
We also leveraged longitudinal laboratory measurements to predict IBD-related flares among patients on maintenance IFX and provide summary statistics of these labs below.
Ultimately, we chose to include the following labs based on their biological plausability: basophils, calcium, CO<sub>2</sub>, creatinine, eosinophils, glucose, hemoglobin, lymphocytes, platelet count, and white blood cell count.
Other potentially relevant variables were excluded due to high missingness (e.g., iron calcium, CRP) or due to high correlation with other variables (e.g., red blood cells, hematocrit, neutrophils).
Specifically, in Figure \@ref(fig:subchunk-19), we note that fewer than 35% of patients had iron calcium and CRP labs prior to their index date, and in Figure \@ref(fig:subchunk-22), we provide a heatmap of the pairwise correlations between the available labs, highlighting strong positive correlations between hemoglobin, hematocrit, and red blood cells as well as between neutrophils and white blood cells.
We further show the distribution of lab values for each type of lab in Figure \@ref(fig:subchunk-20). Notably, of the selected variables, the calcium, creatinine, eosinophils, glucose, lymphocytes, platelet count, and white blood cell count distributions are moderately-to-highly right-skewed and were thus log-transformed for our analyses.
</div>

### Number of Labs {.unnumbered .tabset .tabset-pills .tabset-circle}

```{r nlab-distribution, results = "asis", eval = TRUE}
lab_names <- sort(unique(lab_df_orig$LabName))
lab_df_summary <- lab_df_orig |>
  dplyr::group_by(LabName) |>
  dplyr::summarise(
    `# Unique Patients with Labs` = sprintf(
      "%s (%.2f%%)", 
      length(unique(deId)), 
      length(unique(deId)) / nrow(patient_df_orig) * 100
    ),
    `# Unique Patients with Labs at IFX Index` = sprintf(
      "%s (%.2f%%)", 
      length(unique(deId[LabDate <= 0])), 
      length(unique(deId[LabDate <= 0])) / nrow(patient_df_orig) * 100
    ),
    `# Total Labs` = dplyr::n()
  )
lab_df_summary |>
  vthemes::pretty_DT(
    rownames = FALSE, 
    options = list(
      dom = "t", ordering = FALSE, pageLength = nrow(lab_df_summary)
    )
  ) |>
  vthemes::subchunkify(
    i = subchunk_idx, add_class = padded_panel_class,
    caption = "'Summary table showing the number of unique patients with each type of lab, number of unique patients with each type of lab prior to the IFX index date, and the total number of labs for each type.'"
  )
subchunk_idx <- subchunk_idx + 1
```

### Distribution of Labs {.unnumbered .tabset .tabset-pills .tabset-circle}

```{r lab-distribution, results = "asis", eval = TRUE}
plt <- lab_df_orig |>
  ggplot2::ggplot() +
  ggplot2::aes(x = LabValue) +
  ggplot2::geom_density(fill = "#6FBBE3", alpha = 0.4) +
  ggplot2::facet_wrap(~ LabName, scales = "free") +
  ggplot2::labs(
    x = "Lab Value", y = "Density"
  ) +
  vthemes::theme_vmodern(size_preset = "medium")
vthemes::subchunkify(
  plt, i = subchunk_idx, add_class = panel_class,
  fig_width = fig_width, fig_height = fig_height,
  caption = "'Distribution of all laboratory values for each type of lab among the study population.'"
)
subchunk_idx <- subchunk_idx + 1
```

### Number of Labs Per Patient {.unnumbered .tabset .tabset-pills .tabset-circle}

```{r nlab-per-patient-distribution, results = "asis", eval = TRUE}
plt <- lab_df_orig |>
  dplyr::group_by(LabName, deId) |>
  dplyr::summarise(
    n_labs_per_patient = dplyr::n(),
    .groups = "drop"
  ) |>
  ggplot2::ggplot() +
  ggplot2::aes(x = n_labs_per_patient) +
  ggplot2::geom_histogram(fill = "#6FBBE3", color = "grey98", bins = 20) +
  ggplot2::facet_wrap(~ LabName, scales = "free") +
  ggplot2::labs(
    x = "# Labs Per Patient", y = "Frequency"
  ) +
  vthemes::theme_vmodern(size_preset = "medium")
vthemes::subchunkify(
  plt, i = subchunk_idx, add_class = panel_class,
  fig_width = fig_width, fig_height = fig_height,
  caption = "'Distribution of the number of labs per patient for each type of lab.'"
)
subchunk_idx <- subchunk_idx + 1
```

### Pairwise Relationships between Labs {.unnumbered .tabset .tabset-pills .tabset-circle}

```{r lab-correlations, results = "asis", eval = TRUE}
lab_df_orig_wide <- lab_df_orig |>
  dplyr::distinct(LabName, deId, LabDate, .keep_all = TRUE) |>
  tidyr::pivot_wider(
    id_cols = c(deId, LabDate),
    names_from = LabName,
    values_from = LabValue
  ) 
plt <- lab_df_orig_wide |>
  dplyr::select(tidyselect::all_of(lab_names)) |>
  vdocs::plot_cor_heatmap(
    text_size = 3, x_text_angle = TRUE, size_preset = "medium"
  ) +
  ggplot2::labs(x = "Lab", y = "Lab", fill = "Pearson\nCorrelation")
vthemes::subchunkify(
  plt, i = subchunk_idx, add_class = panel_class,
  fig_width = fig_width, fig_height = fig_height,
  caption = "'Correlation heatmap of the pairwise relationships between available labs.'"
)
subchunk_idx <- subchunk_idx + 1

# get x text labels from plt
clustered_lab_names <-
  ggplot2::ggplot_build(plt)$layout$panel_params[[1]]$x$get_labels()
plt <- lab_df_orig_wide |>
  vdocs::plot_pairs(
    columns = clustered_lab_names, 
    subsample = 0.1, 
    point_size = 0.05
  )
vthemes::subchunkify(
  plt, i = subchunk_idx, fig_height = 14, fig_width = 14,
  add_class = panel_class,
  caption = "'Pairwise scatterplot of the pairwise relationships between available labs.'"
)
subchunk_idx <- subchunk_idx + 1
```

### Labs by Flare Status {.unnumbered .tabset .tabset-pills .tabset-circle}

```{r lab-by-flares, results = "asis", eval = TRUE}
merged_lab_df <- dplyr::left_join(
  lab_df_wide, merged_df, by = "deId"
)
stat_names <- c(
  "Mean Lab" = "mean_lab_value_accrual",
  "Max Lab" = "max_lab_value_accrual",
  "SD Lab" = "sd_lab_value_accrual",
  "Total Variation of Lab" = "tv_lab_value_accrual",
  "Slope of Lab" = "ols_slope_lab_value_accrual"
)
for (stat_name in names(stat_names)) {
  stat <- stat_names[[stat_name]]
  plt <- merged_lab_df |>
    dplyr::select(event, tidyselect::starts_with(stat)) |>
    dplyr::rename_with(~ stringr::str_remove(.x, sprintf("%s_", stat))) |>
    tidyr::pivot_longer(
      cols = -event, names_to = "Lab", values_to = stat_name
    ) |>
    ggplot2::ggplot() +
    ggplot2::aes(x = !!rlang::sym(stat_name), fill = event) +
    ggplot2::geom_density(alpha = 0.4) +
    ggplot2::facet_wrap(~ Lab, scales = "free") +
    ggplot2::labs(
      x = stat_name, y = "Density", fill = "Flare"
    ) +
    vthemes::theme_vmodern(size_preset = "medium")
  vthemes::subchunkify(
    plt, i = subchunk_idx, add_class = panel_class,
    fig_width = fig_width, fig_height = fig_height,
    caption = sprintf(
      "'Distribution of the %s value (per patient) for each lab type, stratified by patients who flared and did not flare.'", 
      stringr::str_to_lower(stat_name)
    )
  )
  subchunk_idx <- subchunk_idx + 1
}
```

# Classification Analysis: Prediction Performance {.tabset .tabset-vmodern}

<div class="panel panel-default padded-panel">
We next provide supplementary results related to our developed classification models for predicting whether or not a patient will experience an IBD-related flare. In particular, in [@hou2025prediction](), we focused on classification models, trained on the patient and lab data, where missing values were imputed using a random forest-based imputation. Here, we provide analogous prediction performance results from classification models, trained on patient and lab data, where missing values were imputed by the feature mean or median. This is to show that our classification models and their prediction performance results are highly robust to this choice of data preprocessing. In particular, we highlight the following:

- **Model selection**: the RF+ is consistently the beset model (according to its validation prediction performance), regardless of the choice of imputation method
- **Prediction accuracy**: the mean test AUROC, AUPRC, sensitivity, specificity, and optimal threshold for the best model (i.e., RF+) are very similar across the different imputation methods; in fact, these test performance metrics do not vary by more than 0.03 across the different imputation methods
- **Calibration**: the RF+ model is well-calibrated regardless of the choice of imputation method
- **Decision curve analysis**: the net benefit of RF+ is consistently high across the different imputation methods
</div>

```{r class-prediction, results = "asis", eval = TRUE}
metrics <- c("auroc", "auprc")
rm_metrics <- c("f1", "accuracy")
rm_varset_modes <- c("Mean, Max, Slope, Recent Labs Only")
impute_modes <- c("rf", "mean", "median")
errs_df <- load_classification_results(
  valid_fname = "validation_errors.csv",
  test_fname = "test_errors.csv"
) |>
  dplyr::select(
    -V1, -tidyselect::all_of(rm_metrics)
  )
errs_df_long <- errs_df |>
  tidyr::pivot_longer(
    cols = tidyselect::all_of(metrics),
    names_to = "metric",
    values_to = "estimate"
  )

for (split_mode in c("validation", "test")) {
  cat(
    sprintf(
      "\n\n## %s Prediction {.unnumbered .tabset .tabset-pills .tabset-square}\n\n",
      stringr::str_to_title(split_mode)
    )
  )

  for (impute_mode in impute_modes) {
    impute_mode_name <- dplyr::case_when(
      impute_mode == "rf" ~ "RF",
      TRUE ~ impute_mode
    )
    nreps <- dplyr::case_when(
      impute_mode == "rf" ~ 50,
      TRUE ~ 20
    )
    cat(
      sprintf(
        "\n\n### %s Imputation {.unnumbered .tabset .tabset-pills .tabset-circle}\n\n",
        R.utils::capitalize(impute_mode_name)
      )
    )
    if (split_mode == "test") {
      cat("\n\n#### Overview of Best Model (RF+) {.unnumbered}\n\n")
      kab <- readRDS(
        file.path(
          FIGURES_DIR, sprintf("test_errors_table_%s_imputed.rds", impute_mode)
        )
      )
      kab |>
        vthemes::subchunkify(
          i = subchunk_idx, add_class = padded_panel_class
        )
      subchunk_idx <- subchunk_idx + 1
    }
    for (metric in metrics) {
      metric_name <- dplyr::case_when(
        metric == "auroc" ~ "AUROC",
        metric == "auprc" ~ "AUPRC",
        TRUE ~ stringr::str_to_title(metric)
      )
      cat(
        sprintf("\n\n#### %s {.unnumbered}\n\n", metric_name)
      )
      
      # prediction error plot
      cat("\n\n##### Prediction Accuracy {.unnumbered}\n\n")
      plt_df <- errs_df_long |>
        dplyr::filter(
          split_mode == !!split_mode,
          is.na(censor_switcher),
          impute_mode == !!impute_mode,
          !(varset_mode %in% !!rm_varset_modes),
          metric == !!metric
        ) |>
        dplyr::group_by(
          method, censor_switcher, impute_mode,
          forecast, forecast_name, accrual, accrual_name, varset_mode, metric
        ) |>
        dplyr::summarise(
          mean_estimate = mean(estimate),
          sd_estimate = sd(estimate),
          se_estimate = sd(estimate) / sqrt(dplyr::n()),
          n_estimate = dplyr::n(),
          .groups = "drop"
        )
      plt <- plt_df |>
        dplyr::mutate(
          forecast = forcats::fct_inseq(as.factor(forecast))
        ) |>
        ggplot2::ggplot() +
        ggplot2::geom_line(
          ggplot2::aes(
            x = forecast, 
            y = mean_estimate, 
            color = varset_mode,
            group = varset_mode
          )
        ) +
        ggplot2::geom_ribbon(
          ggplot2::aes(
            x = forecast,
            ymin = mean_estimate - se_estimate,
            ymax = mean_estimate + se_estimate,
            fill = varset_mode,
            group = varset_mode
          ),
          alpha = 0.1
        ) +
        ggplot2::facet_grid(accrual_name ~ method, scales = "free") +
        ggplot2::labs(
          x = "Forecast Period (months)",
          y = metric_name, 
          color = "Variables Used",
          fill = "Variables Used"
        ) +
        vthemes::scale_color_vmodern(discrete = TRUE) +
        vthemes::scale_fill_vmodern(discrete = TRUE) +
        vthemes::theme_vmodern(size_preset = "medium")
      vthemes::subchunkify(
        plt, i = subchunk_idx, add_class = panel_class,
        fig_width = fig_width * 1.5, fig_height = 7,
        caption = sprintf(
          "'%s %s prediction performance using %s imputation and various prediction models (column) with different sets of predictor variables (color). Results are shown for different forecasting (x-axis) and accrual periods (row). Higher values indicate more accurate prediction performance. Results are averaged across %s random training-validation-test splits. Standard errors are shown as shaded regions around the mean estimates.'",
          stringr::str_to_title(split_mode), metric_name, impute_mode_name, nreps
        )
      )
      subchunk_idx <- subchunk_idx + 1
      
      cat("\n\n##### Prediction Accuracy for Mean, Max, Recent Labs Only {.unnumbered}\n\n")
      plt_df <- errs_df_long |>
        dplyr::filter(
          split_mode == !!split_mode,
          is.na(censor_switcher),
          impute_mode == !!impute_mode,
          varset_mode == "Mean, Max, Recent Labs Only",
          metric == !!metric
        ) |>
        dplyr::group_by(
          method, censor_switcher, impute_mode,
          forecast, forecast_name, accrual, accrual_name, varset_mode, metric
        ) |>
        dplyr::summarise(
          mean_estimate = mean(estimate),
          sd_estimate = sd(estimate),
          se_estimate = sd(estimate) / sqrt(dplyr::n()),
          n_estimate = dplyr::n(),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          method_type = dplyr::case_when(
            method %in% c("RF", "GBDT") ~ "tree",
            method %in% c("Lasso", "Ridge", "Elastic Net", "Logistic") ~ "linear",
            TRUE ~ method
          )
        )
      plt <- plt_df |>
        ggplot2::ggplot() +
        ggplot2::geom_point(
          ggplot2::aes(x = method, y = mean_estimate, color = method_type)
        ) +
        ggplot2::geom_errorbar(
          ggplot2::aes(
            x = method,
            ymin = mean_estimate - se_estimate,
            ymax = mean_estimate + se_estimate,
            color = method_type
          ),
          width = 0
        ) +
        ggplot2::facet_grid(accrual_name ~ forecast_name, scales = "free") +
        ggplot2::labs(
          x = "Method",
          y = metric_name
        ) +
        ggplot2::scale_color_manual(
          values = c("grey70", "#F8766D", "black", "#14CED3")
        ) +
        vthemes::theme_vmodern(size_preset = "medium") +
        ggplot2::theme(
          axis.text.x = ggplot2::element_text(
            size = 12, angle = 90, hjust = 1, vjust = 0.5
          )
        ) +
        ggplot2::guides(color = "none")
      vthemes::subchunkify(
        plt, i = subchunk_idx, add_class = panel_class,
        fig_width = fig_width, fig_height = fig_height,
        caption = sprintf(
          "'%s %s prediction performance using %s imputation and various prediction models (x-axis) with the mean, max, recent labs only. Results are shown for different forecasting (columns) and accrual periods (rows). Higher values indicate more accurate prediction performance. Colors represent the method type: black = RF+, blue = tree-based methods, red = linear-based methods, gray = automated machine learning. Results are averaged across %s random training-validation-test splits. Standard errors are shown as error bars around the mean estimates.'",
          stringr::str_to_title(split_mode), metric_name, impute_mode_name, nreps
        )
      )
      subchunk_idx <- subchunk_idx + 1

      if (split_mode == "validation") {
        cat("\n\n##### Direct RF+ Comparison using Mean, Max, Recent Labs Only {.unnumbered}\n\n")
        plt_df <- errs_df_long |>
          dplyr::filter(
            split_mode == !!split_mode,
            is.na(censor_switcher),
            impute_mode == !!impute_mode,
            varset_mode == "Mean, Max, Recent Labs Only",
            metric == !!metric
          ) |>
          tidyr::pivot_wider(
            names_from = method,
            values_from = estimate
          ) |>
          dplyr::mutate(
            dplyr::across(
              tidyselect::all_of(unique(errs_df_long$method)),
              ~ `RF+` - .x
            )
          ) |>
          tidyr::pivot_longer(
            cols = tidyselect::all_of(unique(errs_df_long$method)),
            names_to = "method",
            values_to = "diff"
          ) |>
          dplyr::filter(
            method != "RF+"
          ) |>
          dplyr::mutate(
            method = rename_classification_methods(method)
          )
        plt_pvals_df <- plt_df |>
          dplyr::group_by(
            censor_switcher, impute_mode, varset_mode, split_mode, metric,
            forecast, forecast_name, accrual, accrual_name, method
          ) |>
          dplyr::summarise(
            perm_pval = purrr::map_lgl(
              1:1000,
              ~ mean(
                sample(c(1, -1), size = length(diff), replace = TRUE) * diff
              ) >
                mean(diff)
            ) |> 
              mean(),
            t_pval = t.test(
              diff, mu = 0, alternative = "greater"
            )$p.value,
            wilcox_pval = wilcox.test(
              diff, mu = 0, alternative = "greater"
            )$p.value,
            .groups = "drop"
          ) |>
          dplyr::mutate(
            pval_label = dplyr::case_when(
              perm_pval < 0.001 ~ "***",
              perm_pval < 0.01 ~ "**",
              perm_pval < 0.05 ~ "*",
              TRUE ~ ""
            )
          )
        plt <-  plt_df |>
          ggplot2::ggplot() +
          ggplot2::geom_boxplot(
            ggplot2::aes(
              x = method, y = diff 
            ),
            outlier.size = 0.75
          ) +
          ggplot2::geom_text(
            ggplot2::aes(
              x = method, y = Inf, label = pval_label
            ),
            angle = 90, hjust = 1, vjust = 0.75, size = 7,
            data = plt_pvals_df
          ) +
          ggplot2::geom_hline(yintercept = 0, linetype = "dashed") +
          ggplot2::facet_grid(accrual_name ~ forecast_name, scales = "free_y") +
          ggplot2::labs(
            x = "Method", 
            y = sprintf("RF+ %s - Model %s", metric_name, metric_name)
          ) +
          vthemes::theme_vmodern(
            size_preset = "medium"
          ) +
          ggplot2::theme(
            axis.text.x = ggplot2::element_text(
              size = 12, angle = 90, hjust = 1, vjust = 0.5
            )
          )
        vthemes::subchunkify(
          plt, i = subchunk_idx, add_class = panel_class,
          fig_width = fig_width, fig_height = fig_height,
          caption = sprintf(
            "'Distribution of pairwise differences between the validation %s from RF+ with mean, max, recent labs and that from competitor methods (x-axis) across different forecasting (columns) and accrual periods (rows) when using %s imputation during the data preprocessing. Astericks denote statistical significance from a permutation test, assessing whether these differences are significantly greater than 0 (i.e., whether RF+ yields higher prediction accuracy than the competitor method). Specifically, *** denotes p < 0.001, ** denotes p < 0.01, and * denotes p < 0.05. Results are shown for %s random training-validation-test splits.'",
            metric_name, impute_mode_name, nreps
          )
        )
        subchunk_idx <- subchunk_idx + 1
      }
    }
  }
}
```

## Calibration {.unnumbered .tabset .tabset-pills .tabset-square}

```{r class-calibration, results = "asis", eval = TRUE}
for (impute_mode in impute_modes) {
  impute_mode_name <- dplyr::case_when(
    impute_mode == "rf" ~ "RF",
    TRUE ~ impute_mode
  )
  cat(sprintf("\n\n### %s Imputation {.unnumbered}\n\n", R.utils::capitalize(impute_mode_name)))

  calibration_df <- load_classification_results(
    test_fname = "test_calibration_results.csv"
  ) |>
    dplyr::filter(
      method == "RF+",
      is.na(censor_switcher),
      impute_mode == !!impute_mode,
      varset_mode == "Mean, Max, Recent Labs Only",
      split_mode == "test"
    )

  plt_df <- calibration_df |>
    dplyr::group_by(
      method, quantile, censor_switcher, impute_mode,
      forecast, forecast_name, accrual, accrual_name, varset_mode, split_mode
    ) |>
    dplyr::summarise(
      num_flares = mean(num_flares),
      predicted_flares = mean(predicted_flares),
      .groups = "drop"
    )

  plt <- plt_df |>
    ggplot2::ggplot() +
    ggplot2::aes(
      x = num_flares, 
      y = predicted_flares, 
      color = as.factor(forecast), 
      shape = as.factor(accrual)
    ) +
    ggplot2::geom_point(size = 3) +
    ggplot2::geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
    ggplot2::labs(
      x = "Number of Observed Flares", 
      y = "Number of Predicted Flares",
      color = "Forecast (mo)",
      shape = "Accrual (yr)"
    ) +
    vthemes::theme_vmodern(size_preset = "medium")
  vthemes::subchunkify(
    plotly::ggplotly(plt), i = subchunk_idx, add_class = padded_panel_class,
    fig_width = fig_width, fig_height = fig_height,
    caption = sprintf(
      "'Calibration plot showing the relationship between the number of observed flares and the number of predicted flares for the RF+ model using %s imputation. Each point represents a different forecasting period (color) and accrual period (shape). The dashed line represents perfect calibration.'",
      impute_mode_name
    )
  )
  subchunk_idx <- subchunk_idx + 1
}
```

## Decision Curve Analysis {.unnumbered .tabset .tabset-pills .tabset-square}

```{r class-dca, results = "asis", eval = TRUE}
for (impute_mode in impute_modes) {
  impute_mode_name <- dplyr::case_when(
    impute_mode == "rf" ~ "RF",
    TRUE ~ impute_mode
  )
  cat(sprintf("\n\n### %s Imputation {.unnumbered}\n\n", R.utils::capitalize(impute_mode_name)))

  dca_df <- load_classification_results(test_fname = "test_dca_results.csv") |>
    dplyr::filter(
      is.na(censor_switcher), 
      impute_mode == !!impute_mode,
      varset_mode == "Mean, Max, Recent Labs Only"
    )

  best_cutoffs <- load_classification_results(
    test_fname = "test_best_cutoff_results.csv"
  ) |>
    dplyr::filter(
      is.na(censor_switcher), 
      impute_mode == !!impute_mode,
      varset_mode == "Mean, Max, Recent Labs Only",
      method == "RF+"
    ) |>
    dplyr::group_by(
      method, censor_switcher, impute_mode,
      forecast, forecast_name, accrual, accrual_name, varset_mode
    ) |>
    dplyr::summarise(
      sensitivity = mean(sensitivity),
      specificity = mean(specificity),
      thr = mean(thr),
      .groups = "drop"
    ) |>
    dplyr::rename(model = method)

  plt_df <- dca_df |>
    dplyr::group_by(
      model, threshold, method, censor_switcher, impute_mode, 
      forecast, forecast_name, accrual, accrual_name, varset_mode
    ) |>
    dplyr::summarise(
      net_benefit = mean(net_benefit),
      net_benefit_sd = sd(net_benefit),
      net_benefit_se = sd(net_benefit) / sqrt(dplyr::n()),
      net_benefit_n = dplyr::n(),
      .groups = "drop"
    )

  plt <- plt_df |>
    dplyr::filter(
      !(method == "Logistic" & model != "pred"),
      threshold <= 0.35,
      net_benefit >= -0.1
    ) |>
    dplyr::mutate(
      model = dplyr::case_when(
        model == "all" ~ "Treat All",
        model == "none" ~ "Treat None",
        method == "Logistic" ~ "Logistic Model",
        method == "RF+" ~ "RF+ Model"
      ) |>
        factor(
          levels = c("RF+ Model", "Logistic Model", "Treat All", "Treat None")
        )
    ) |>
    ggplot2::ggplot() +
    ggplot2::geom_line(
      ggplot2::aes(
        x = threshold, y = net_benefit, color = model
      )
    ) +
    ggplot2::geom_vline(
      ggplot2::aes(xintercept = thr),
      data = best_cutoffs,
      linetype = "dotted"
    ) +
    ggplot2::facet_grid(accrual_name ~ forecast_name) + 
    ggplot2::scale_color_manual(
      values = c(
        "black", "#F8766D", "#619CFF", "#00BA38"
      )
    ) +
    ggplot2::coord_cartesian(expand = FALSE) +
    ggplot2::labs(
      x = "Threshold Probability",
      y = "Net Benefit",
      color = ""
    ) +
    vthemes::theme_vmodern(size_preset = "medium")

  vthemes::subchunkify(
    plotly::ggplotly(plt), i = subchunk_idx, add_class = padded_panel_class,
    fig_width = fig_width, fig_height = fig_height,
    caption = "'Decision curve analysis showing the net benefit of the RF+ model using %s imputation compared to that from the logistic regression model, treating all patients, or treating no patients. The net benefit is shown across different threshold probabilities (x-axis) for different forecasting (columns) and accrual periods (rows). The dotted line represents the threshold probability corresponding to the optimal sensitivity and specificity for the RF+ model. RF+ yields higher net benefit than the other strategies across a range of reasonable threshold probabilities.'"
  )
  subchunk_idx <- subchunk_idx + 1
}
```

# Classification Analysis: Interpretation {.tabset .tabset-vmodern}

<div class="panel panel-default padded-panel">
In addition to the robust prediction performance, the interpretation of our classification models, according to the feature importances, are also robust to the choice of imputation method during data preprocessing, as seen below.
</div>

## Feature Importance by Model {.unnumbered .tabset .tabset-pills .tabset-square}

```{r class-importance, results = "asis", eval = TRUE}
vimps_df <- load_classification_results(
  test_fname = "test_importances.csv"
) |>
  dplyr::filter(
    is.na(censor_switcher),
    varset_mode == "Mean, Max, Recent Labs Only"
  ) |>
  dplyr::mutate(
    var = rename_variables(var)
  )
for (method in setdiff(levels(vimps_df$method), "Autogluon")) {
  cat(
    sprintf(
      "\n\n### %s {.unnumbered .tabset .tabset-pills .tabset-circle}\n\n",
      method
    )
  )

  for (impute_mode in impute_modes) {
    impute_mode_name <- dplyr::case_when(
      impute_mode == "rf" ~ "RF",
      TRUE ~ impute_mode
    )
    nreps <- dplyr::case_when(
      impute_mode == "rf" ~ 50,
      TRUE ~ 20
    )
    cat(sprintf("\n\n#### %s Imputed {.unnumbered}\n\n", R.utils::capitalize(impute_mode_name)))
    plt_df_all <- vimps_df |>
      dplyr::filter(
        method == !!method,
        impute_mode == !!impute_mode
      )

    plt_ls <- list()
    for (forecast in c(3, 6, 12)) {
      for (accrual in c(1, 2)) {
        plt_name <- sprintf(
          "Accrual = %syr, Forecast = %smo", accrual, forecast
        )
        plt_df <- plt_df_all |>
          dplyr::filter(
            forecast == !!forecast,
            accrual == !!accrual
          ) |>
          dplyr::group_by(
            forecast_name, accrual_name, var
          ) |>
          dplyr::summarise(
            mean_importance = mean(importance),
            sd_importance = sd(importance),
            se_importance = sd(importance) / sqrt(dplyr::n()),
            .groups = "drop"
          )
        var_order <- plt_df |>
          dplyr::arrange(-mean_importance) |>
          dplyr::pull(var)
        plt_ls[[plt_name]] <- plt_df |>
          dplyr::mutate(
            var = factor(var, levels = rev(var_order))
          ) |>
          dplyr::filter(
            !is.na(var)
          ) |>
          ggplot2::ggplot() +
          ggplot2::geom_point(
            ggplot2::aes(
              x = var,
              y = mean_importance
            )
          ) +
          ggplot2::geom_errorbar(
            ggplot2::aes(
              x = var,
              ymin = mean_importance - se_importance,
              ymax = mean_importance + se_importance
            ),
            width = 0
          ) +
          ggplot2::facet_grid(accrual_name ~ forecast_name) +
          ggplot2::labs(
            x = "Variable",
            y = "Importance"
          ) +
          ggplot2::coord_flip() +
          vthemes::theme_vmodern(
            size_preset = "large"
          )
        if (accrual == 2) {
          plt_ls[[plt_name]] <- plt_ls[[plt_name]] +
            ggplot2::theme(
              strip.text.x = ggplot2::element_blank(),
              strip.background.x = ggplot2::element_blank()
            )
        }
        if (forecast != 12) {
          plt_ls[[plt_name]] <- plt_ls[[plt_name]] +
            ggplot2::theme(
              strip.text.y = ggplot2::element_blank(),
              strip.background.y = ggplot2::element_blank()
            )
        }
      }
    }
    plt <- patchwork::wrap_plots(
      plt_ls, nrow = 2, ncol = 3, byrow = FALSE, guides = "collect"
    ) +
      patchwork::plot_layout(axis_titles = "collect")
    vthemes::subchunkify(
      plt, i = subchunk_idx, add_class = panel_class,
      fig_width = fig_width * 2, fig_height = fig_height * 2.5,
      caption = sprintf(
        "'Summary of feature importances from the %s model using %s imputation during the data preprocessing. Each point represents the mean importance of a variable across %s random training-validation-test splits. Error bars represent standard errors around the mean estimates. Variables are ordered by their mean importance with higher values indicating greater importance. Results are shown for different forecasting (columns) and accrual periods (rows).'",
        method, impute_mode_name, nreps
      )
    )
    subchunk_idx <- subchunk_idx + 1
  }
}
```

## Feature Ranks Summary {.unnumbered .tabset .tabset-pills .tabset-square}

```{r class-importance-ranks, results = "asis", eval = TRUE}
# Importance across methods
vimps_rank_df <- vimps_df |>
  dplyr::group_by(
    method, censor_switcher, impute_mode, varset_mode,
    forecast, forecast_name, accrual, accrual_name, split_mode, var
  ) |>
  dplyr::summarise(
    importance_mean = mean(importance),
    .groups = "drop"
  ) |>
  dplyr::group_by(
    method, censor_switcher, impute_mode, varset_mode,
    forecast, forecast_name, accrual, accrual_name, split_mode
  ) |>
  dplyr::mutate(
    importance_rank = rank(-importance_mean)
  )

for (impute_mode in impute_modes) {
  impute_mode_name <- dplyr::case_when(
    impute_mode == "rf" ~ "RF",
    TRUE ~ impute_mode
  )
  nreps <- dplyr::case_when(
    impute_mode == "rf" ~ 50,
    TRUE ~ 20
  )
  cat(sprintf("\n\n### %s Imputation {.unnumbered}\n\n", R.utils::capitalize(impute_mode_name)))

  plt_ls <- list()
  for (forecast in c(3, 6, 12)) {
    for (accrual in c(1, 2)) {
      plt_name <- sprintf(
        "Accrual = %syr, Forecast = %smo", accrual, forecast
      )
      plt_df <- vimps_rank_df |>
        dplyr::filter(
          forecast == !!forecast,
          accrual == !!accrual,
          impute_mode == !!impute_mode
        )
      var_order <- plt_df |>
        dplyr::filter(method == "RF+") |>
        dplyr::arrange(importance_rank) |>
        dplyr::pull(var)
      plt_ls[[plt_name]] <- plt_df |>
        dplyr::mutate(
          var = factor(var, levels = rev(var_order))
        ) |>
        dplyr::filter(
          !is.na(var)
        ) |>
        ggplot2::ggplot() +
        ggplot2::aes(
          x = method, y = var, fill = importance_rank, label = importance_rank
        ) +
        ggplot2::geom_tile() +
        ggplot2::geom_text(size = 3) +
        ggplot2::facet_grid(accrual_name ~ forecast_name) +
        ggplot2::labs(
          x = "Method", 
          y = "Variable", 
          fill = "Variable\nImportance\nRank"
        ) +
        viridis::scale_fill_viridis(
          option = "magma", direction = -1, limits = c(1, 56),
          guide = ggplot2::guide_colorbar(reverse = TRUE),
          begin = 0.2
        ) +
        ggplot2::coord_cartesian(expand = FALSE) +
        vthemes::theme_vmodern(
          size_preset = "large"
        ) +
        ggplot2::theme(
          axis.text.x = ggplot2::element_text(
            size = 12, angle = 90, hjust = 1, vjust = 0.5
          ),
          panel.border = ggplot2::element_rect(
            color = "black", fill = NA, linewidth = 1
          )
        )
      if (accrual == 2) {
        plt_ls[[plt_name]] <- plt_ls[[plt_name]] +
          ggplot2::theme(
            strip.text.x = ggplot2::element_blank(),
            strip.background.x = ggplot2::element_blank()
          )
      }
      if (forecast != 12) {
        plt_ls[[plt_name]] <- plt_ls[[plt_name]] +
          ggplot2::theme(
            strip.text.y = ggplot2::element_blank(),
            strip.background.y = ggplot2::element_blank()
          )
      }
    }
  }

  plt <- patchwork::wrap_plots(
    plt_ls, nrow = 2, ncol = 3, byrow = FALSE, guides = "collect"
  ) +
    patchwork::plot_layout(axis_titles = "collect")
  vthemes::subchunkify(
    plt, i = subchunk_idx, add_class = panel_class,
    fig_width = fig_width * 2, fig_height = fig_height * 2.5,
    caption = sprintf(
      "'Summary of the feature importance rankings from different models (x-axis) using %s imputation during the data preprocessing. Each tile represents the rank of a variable, according to its mean importance from %s random training-validation-test splits. Results are shown for different forecasting (columns) and accrual periods (rows).'",
      impute_mode_name, nreps
    )
  )
  subchunk_idx <- subchunk_idx + 1
}
```


## RF+ Partial Dependence Plots {.unnumbered .tabset .tabset-pills .tabset-square}

### RF Imputed {.unnumbered}

```{r class-pdp, results = "asis", eval = TRUE}
varset_mode <- "recent_mean_max_labs"
censor_switcher <- ""
impute_mode <- "rf"
seeds <- 1:50
features <- c(
  "# Prior Flares" = "n_prior_flare",
  "# Any Encounters" = "count_anyenc",
  "# IBD Encounters" = "count_IBDenc",
  "Max White Blood Cells" = "max_lab_value_accrual_wbc",
  "Recent Hemoglobin" = "recent_lab_value_hgb",
  "Mean Hemoglobin" = "mean_lab_value_accrual_hgb",
  "Max Platelet" = "max_lab_value_accrual_platelet",
  "# Flares Pre-IFX" = "n_flares_preifx",
  "Mean CO2" = "mean_lab_value_accrual_co2"
)
plt_ls_all <- list()
for (forecast in c(3, 6, 12)) {
  for (accrual in c(1, 2)) {
    plt_name <- sprintf(
      "Accrual = %syr, Forecast = %smo", accrual, forecast
    )
    var_order <- vimps_rank_df |>
      dplyr::filter(
        method == "RF+",
        accrual == !!accrual,
        forecast == !!forecast,
        impute_mode == !!impute_mode
      ) |>
      dplyr::arrange(importance_rank) |>
      dplyr::pull(var)
    keep_vars <- var_order[1:6]
    plt_ls <- list()
    for (feature_name in keep_vars) {
      feature <- features[[feature_name]]
      Xs_ls <- list()
      plt_df_ls <- list()
      for (seed in seeds) {
        # TODO: DELETE AND UNCOMMENT
        pdp_df <- data.table::fread(
          file.path(
            "/scratch/awaljee_root/awaljee99/tmtang/Biosimilar-project/results_copy/classification_models_final_v2",
            sprintf(
              "classification_rolling_wi_accrual_%syr_forecast_%smo_rf_imputed_rep%s", 
              accrual, forecast, seed
            ), 
            sprintf("pdp_%s_%s_seed%s.csv", varset_mode, feature, seed)
          )
        ) |>
          tibble::as_tibble()
        X <- data.table::fread(
          file.path(
            "/scratch/awaljee_root/awaljee99/tmtang/Biosimilar-project/data/processed_final",
            sprintf(
              "classification_rolling_wi_accrual_%syr_forecast_%smo_rf_imputed_rep%s.csv", 
              accrual, forecast, seed
            )
          )
        ) |>
          tibble::as_tibble()
        
        # pdp_df <- data.table::fread(
        #   file.path(
        #     CLASS_RESULTS_DIR,
        #     sprintf(
        #       "classification_accrual_%syr_forecast_%smo%s_%s_imputed_rep%s",
        #       accrual, forecast, censor_switcher, impute_mode, seed
        #     ),
        #     sprintf("test_%s_pdp_%s.csv", varset_mode, feature)
        #   )
        # ) |>
        #   tibble::as_tibble()
        # 
        # X <- data.table::fread(
        #   file.path(
        #     DATA_DIR,
        #     "classification_data",
        #     sprintf(
        #       "classification_accrual_%syr_forecast_%smo%s_%s_imputed_rep%s.csv",
        #       accrual, forecast, censor_switcher, impute_mode, seed
        #     )
        #   )
        # ) |>
        #   tibble::as_tibble()
        feature_data <- X[[feature]]
        x_mean <- mean(feature_data)
        x_sd <- sd(feature_data)
        
        plt_df_ls[[seed]] <- pdp_df |>
          dplyr::mutate(
            orig_grid_values = grid_values * x_sd + x_mean
          )
        Xs_ls[[seed]] <- X |>
          dplyr::select(tidyselect::all_of(feature))
      }
      
      plt_df <- plt_df_ls |>
        dplyr::bind_rows(.id = "seed")
      common_grid_values <- seq(
        quantile(plt_df$orig_grid_values, 0.01),
        quantile(plt_df$orig_grid_values, 0.99),
        length.out = 100
      )
      plt_df <- plt_df |>
        dplyr::group_by(seed) |>
        dplyr::summarise(
          imputed_pdp = list(
            purrr::map(
              common_grid_values,
              function(grid_value) {
                idx <- which(orig_grid_values > grid_value)[1]
                if (is.na(idx)) {
                  idx <- length(orig_grid_values)
                } else if (idx == 1) {
                  idx <- 2
                }
                slope <- (average[idx] - average[idx - 1]) /
                  (orig_grid_values[idx] - orig_grid_values[idx - 1])
                val <- average[idx - 1] + 
                  slope * (grid_value - orig_grid_values[idx - 1])
                return(
                  tibble::tibble_row(
                    orig_grid_values = grid_value,
                    average = val
                  )
                )
              }
            ) |>
              dplyr::bind_rows()
          )
        ) |>
        tidyr::unnest(cols = imputed_pdp) |>
        dplyr::group_by(orig_grid_values) |>
        dplyr::summarise(
          mean = mean(average),
          lo = quantile(average, 0.025),
          hi = quantile(average, 0.975)
        )
      
      plt_ls[[feature]] <- plt_df |>
        ggplot2::ggplot() +
        ggplot2::aes(
          x = orig_grid_values,
          y = mean
        ) +
        ggplot2::geom_line() +
        ggplot2::geom_ribbon(
          ggplot2::aes(x = orig_grid_values, ymin = lo, ymax = hi),
          alpha = 0.2
        ) +
        ggplot2::geom_rug(
          ggplot2::aes(x = .data[[feature]]),
          inherit.aes = FALSE,
          data = dplyr::bind_rows(Xs_ls),
          alpha = 1 / length(seeds) * 0.2
        ) +
        ggplot2::labs(
          x = feature_name, 
          y = "Predicted Risk of Flare"
        ) +
        vthemes::theme_vmodern()
    }
    
    plt <- patchwork::wrap_plots(plt_ls, nrow = 1, ncol = length(plt_ls)) +
      patchwork::plot_layout(axis_titles = "collect_y") +
      patchwork::plot_annotation(
        title = sprintf("Accrual = %syr, Forecast = %smo", accrual, forecast),
        theme = ggplot2::theme(
          title = ggplot2::element_text(face = "bold")
        )
      )
    plt_ls_all[[plt_name]] <- patchwork::wrap_elements(plt)
  }
}

plt <- patchwork::wrap_plots(plt_ls_all, nrow = length(plt_ls_all), ncol = 1)
vthemes::subchunkify(
  plt, i = subchunk_idx, add_class = panel_class,
  fig_width = fig_width * 1.5, fig_height = fig_height * 2,
  caption = "'Partial dependence plots for the top six features from the RF+ (with mean, max, and recent labs only and RF data imputation), showing how the average predicted risk of flare changes across varying values of each feature.'"
)
subchunk_idx <- subchunk_idx + 1
```

# Survival Analysis: Prediction Performance {.tabset .tabset-vmodern}

<div class="panel panel-default padded-panel">
Moving beyond the classification models, we also trained survival models to predict a patient's risk of flaring. Below, we summarize the prediction performance, measured via the concordance index (C-index), of these models across different choices of survival models, sets of predictor variables, forecasting periods, and accrual periods.
</div>

```{r surv-prediction, results = "asis", eval = TRUE}
cindex_df <- dplyr::bind_rows(
  readRDS(
    file.path(SURV_RESULTS_DIR, "validation_cindexs.rds")
  ),
  readRDS(
    file.path(SURV_RESULTS_DIR, "test_cindexs.rds")
  )
)

plt_df <- cindex_df |>
  dplyr::filter(
    varset_mode %in% c("no_labs", "labs_rf_imp"),
    censor_switcher == FALSE
  ) |>
  tidyr::pivot_longer(
    cols = c(ltrc, cox, cox_lasso, cox_ridge),
    names_to = "method",
    values_to = "cindex"
  ) |>
  dplyr::mutate(
    method = rename_survival_methods(method),
    split_mode = stringr::str_to_title(split_mode) |>
      factor(levels = c("Validation", "Test"))
  ) |>
  dplyr::mutate(
    time = time / 365.25,
    varset_mode = dplyr::case_when(
      varset_mode == "no_labs" ~ "No Labs",
      varset_mode == "labs_rf_imp" ~ "Include Labs"
    )
  ) |>
  dplyr::group_by(
    varset_mode, time, forecast, forecast_name, censor_switcher, split_mode, 
    method
  ) |>
  dplyr::summarise(
    cindex_mean = mean(cindex, na.rm = TRUE),
    cindex_sd = sd(cindex, na.rm = TRUE),
    cindex_se = sd(cindex, na.rm = TRUE) / sqrt(dplyr::n()),
    .groups = "drop"
  )

for (split_mode in c("Validation", "Test")) {
  cat(
    sprintf(
      "\n\n## %s C-index {.unnumbered .tabset .tabset-pills .tabset-square}\n\n",
      stringr::str_to_title(split_mode)
    )
  )
  
  cat("\n\n### C-index by Variable Set {.unnumbered}\n\n")
  plt <- plt_df |>
    dplyr::filter(
      time > 1/12, time <= 4,
      split_mode == !!split_mode
    ) |>
    ggplot2::ggplot() +
    ggplot2::aes(
      x = time, 
      y = cindex_mean,
      linetype = varset_mode
    ) +
    ggplot2::geom_line() +
    ggplot2::facet_grid(method ~ forecast_name) +
    ggplot2::labs(
      x = "Accrual Period (yrs)",
      y = "C-index",
      linetype = ""
    ) +
    vthemes::theme_vmodern(size_preset = "medium")
  vthemes::subchunkify(
    plt, i = subchunk_idx, add_class = panel_class,
    fig_width = fig_width, fig_height = fig_height,
    caption = sprintf(
      "'%s C-index from different choices of survival models (columns), predictor variables (line type), forecasting periods (columns), and accrual periods (x-axis). Results are averaged across 50 random training-validation-test splits.'",
      stringr::str_to_title(split_mode)
    )
  )
  subchunk_idx <- subchunk_idx + 1
  
  cat("\n\n### C-index by Method {.unnumbered}\n\n")
  plt <- plt_df |>
    dplyr::filter(
      time > 1/12, time <= 4,
      split_mode == !!split_mode,
      varset_mode == "Include Labs"
    ) |>
    ggplot2::ggplot() +
    ggplot2::geom_line(
      ggplot2::aes(
        x = time,
        y = cindex_mean,
        color = method
      )
    ) +
    ggplot2::geom_ribbon(
      ggplot2::aes(
        x = time,
        ymin = cindex_mean - cindex_se,
        ymax = cindex_mean + cindex_se,
        fill = method
      ),
      alpha = 0.1
    ) +
    ggplot2::facet_grid(~ forecast_name) +
    vthemes::scale_color_vmodern(discrete = TRUE) +
    vthemes::scale_fill_vmodern(discrete = TRUE) +
    ggplot2::labs(
      x = "Accrual Period (yrs)",
      y = "C-index",
      color = "Method",
      fill = "Method"
    ) +
    vthemes::theme_vmodern(size_preset = "medium")
  
  vthemes::subchunkify(
    plt, i = subchunk_idx, add_class = panel_class,
    fig_width = fig_width, fig_height = 5,
    caption = sprintf(
      "'%s C-index from different choices of survival models (color) including the lab values as covariates across forecasting (columns) and accrual periods (x-axis). Results are averaged across 50 random training-validation-test splits.'",
      stringr::str_to_title(split_mode)
    )
  )
  subchunk_idx <- subchunk_idx + 1
}

cat("\n\n### Kaplan Meier Curves {.unnumbered}\n\n")
test_km_df <- readRDS(
  file.path(SURV_RESULTS_DIR, "test_km.rds")
)

plt_df <- test_km_df |>
  dplyr::filter(
    censor_switcher == FALSE,
    varset_mode == "labs_rf_imp",
    !is.na(group),
    accrual == "0.5"
  ) |>
  dplyr::mutate(
    method = rename_survival_methods(method),
    strata = stringr::str_to_title(strata)
  ) |>
  # interpolate survival curves to have the same time points
  dplyr::group_by(
    strata, group, rep, varset_mode, censor_switcher,
    forecast, forecast_name, accrual, accrual_name, split_mode, method
  ) |>
  dplyr::summarise(
    dplyr::across(
      c(surv, std.err, upper, lower),
      ~ approx(
        x = time, y = .x, xout = seq(0, max(time), by = 0.01)
      ) |>
        tibble::as_tibble() |>
        setNames(c("time", dplyr::cur_column())) |>
        dplyr::select(-time) |>
        list()
    ),
    time = tibble::tibble(time = seq(0, max(time), by = 0.01)) |>
      list(),
    .groups = "drop"
  ) |>
  tidyr::unnest(
    c(time, surv, std.err, upper, lower)
  ) |>
  # aggregate survival curves
  dplyr::group_by(
    time, strata, group, varset_mode, censor_switcher,
    forecast, forecast_name, accrual, accrual_name, split_mode, method
  ) |>
  dplyr::summarise(
    dplyr::across(
      c(surv, std.err, upper, lower),
      ~ mean(.x, na.rm = TRUE)
    ),
    .groups = "drop"
  )

plt <- plt_df |>
  dplyr::filter(time <= 4) |>
  ggplot2::ggplot() +
  ggplot2::geom_line(
    ggplot2::aes(
      x = time, y = surv, color = strata
    )
  ) +
  ggplot2::geom_ribbon(
    ggplot2::aes(
      x = time, ymin = lower, ymax = upper, fill = strata
    ),
    alpha = 0.2
  ) +
  ggplot2::facet_grid(
    forecast_name ~ method
  ) +
  ggplot2::labs(
    x = "Time (yrs)", y = "Flare-free Survival",, 
    color = "Risk Strata", fill = "Risk Strata"
  ) +
  ggplot2::guides(
    color = ggplot2::guide_legend(reverse = TRUE),
    fill = ggplot2::guide_legend(reverse = TRUE)
  ) +
  vthemes::theme_vmodern(size_preset = "medium")
vthemes::subchunkify(
  plt, i = subchunk_idx, add_class = panel_class,
  fig_width = fig_width * 1.25, fig_height = fig_height * 1.2,
  caption = sprintf(
    "'Kaplan-Meier curves showing the flare-free survival probability over time for different risk strata (colors) using different survival models (columns) with lab values as covariates. Results are shown across different forecasting (columns) and accrual periods (rows).'"
  )
)
subchunk_idx <- subchunk_idx + 1
```

# Survival Analysis: Interpretation {.tabset .tabset-vmodern}

<div class="panel panel-default padded-panel">
To understand how these survival models are arriving at their estimated survival probabilities, we show the feature importances from the various survival models below.
</div>

## Feature Importance {.unnumbered .tabset .tabset-pills .tabset-square}

```{r surv-importance, results = "asis", eval = TRUE}
vimps_df <- readRDS(
  file.path(SURV_RESULTS_DIR, "test_importances.rds")
)

plt_df_all <- vimps_df |>
  dplyr::mutate(
    method = rename_survival_methods(method),
    variable = rename_variables(variable)
  ) |>
  dplyr::filter(
    censor_switcher == FALSE,
    varset_mode == "labs_rf_imp"
  ) |>
  dplyr::group_by(
    forecast, forecast_name, censor_switcher, varset_mode, method, variable
  ) |>
  dplyr::summarise(
    dplyr::across(
      c(importance, estimate, statistic, p.value, HR),
      list(
        mean = ~ mean(.x, na.rm = TRUE),
        sd = ~ sd(.x, na.rm = TRUE),
        se = ~ sd(.x, na.rm = TRUE) / sqrt(dplyr::n())
      )
    ),
    .groups = "drop"
  )

plt_ls <- list()
for (method_name in levels(plt_df_all$method)) {
  cat(
    sprintf("\n\n### %s {.unnumbered}\n\n", method_name)
  )
  plt_df <- plt_df_all |>
    dplyr::filter(
      method == !!method_name
    )
  var_order <- plt_df |>
    dplyr::group_by(variable) |>
    dplyr::summarise(
      mean_importance = mean(importance_mean)
    ) |>
    dplyr::arrange(-mean_importance) |>
    dplyr::pull(variable)
  plt <- plt_df |>
    dplyr::mutate(
      variable = factor(variable, levels = rev(var_order))
    ) |>
    ggplot2::ggplot() +
    ggplot2::geom_point(
      ggplot2::aes(
        x = importance_mean, y = variable
      ),
      size = 0.75
    ) +
    ggplot2::geom_errorbar(
      ggplot2::aes(
        xmin = importance_mean - importance_se, 
        xmax = importance_mean + importance_se,
        y = variable
      ),
      width = 0.1
    ) +
    ggplot2::facet_grid(method ~ forecast_name) +
    ggplot2::labs(
      x = "Importance", y = "Variable"
    ) +
    vthemes::theme_vmodern(size_preset = "medium")
  vthemes::subchunkify(
    plt, i = subchunk_idx, add_class = panel_class,
    fig_width = fig_width, fig_height = 6,
    caption = sprintf(
      "'Summary of feature importances from the %s survival model for different forecasting periods (columns). Each point represents the mean importance of a variable across 50 random training-validation-test splits. Error bars represent standard errors around the mean estimates. Variables are ordered by their mean importance with highger values indicating greater importance.'",
      method_name
    )
  )
  subchunk_idx <- subchunk_idx + 1
}
```

### Feature Ranks Summary {.unnumbered .tabset .tabset-pills .tabset-circle}

```{r surv-importance-ranks, results = "asis", eval = TRUE}
# Importance across methods
vimps_rank_df <- vimps_df |>
  dplyr::group_by(
    method, censor_switcher, varset_mode, forecast, forecast_name, variable
  ) |>
  dplyr::summarise(
    importance_mean = mean(importance),
    .groups = "drop"
  ) |>
  dplyr::group_by(
    method, censor_switcher, varset_mode, forecast, forecast_name
  ) |>
  dplyr::mutate(
    importance_rank = rank(-importance_mean),
    method = rename_survival_methods(method),
    variable = rename_variables(variable)
  )

plt_ls <- list()
for (forecast in c(3, 6, 12)) {
  plt_name <- sprintf("Forecast = %smo", forecast)
  plt_df <- vimps_rank_df |>
    dplyr::filter(
      forecast == !!forecast
    )
  var_order <- plt_df |>
    dplyr::filter(method == "LTRC RF") |>
    dplyr::arrange(importance_rank) |>
    dplyr::pull(variable)
  for (var in setdiff(unique(plt_df$variable), var_order)) {
    rootvar <- stringr::str_extract(var, "[^:]+(?=:)")
    rootvar_idx <- which(var_order == rootvar)
    var_order <- c(
      var_order[1:rootvar_idx], 
      var, 
      var_order[(rootvar_idx + 1):length(var_order)]
    )
  }
  plt_ls[[plt_name]] <- plt_df |>
    dplyr::mutate(
      variable = factor(variable, levels = rev(var_order))
    ) |>
    # dplyr::filter(
    #   !is.na(variable)
    # ) |>
    ggplot2::ggplot() +
    ggplot2::aes(
      x = method, y = variable, fill = importance_rank, label = importance_rank
    ) +
    ggplot2::geom_tile() +
    ggplot2::geom_text(size = 3) +
    ggplot2::facet_grid(~ forecast_name) +
    ggplot2::labs(
      x = "Method", 
      y = "Variable", 
      fill = "Variable\nImportance\nRank"
    ) +
    viridis::scale_fill_viridis(
      option = "magma", direction = -1, limits = c(1, 56),
      guide = ggplot2::guide_colorbar(reverse = TRUE),
      begin = 0.2
    ) +
    ggplot2::coord_cartesian(expand = FALSE) +
    vthemes::theme_vmodern(
      size_preset = "large", grid_color = "gray90", bg_color = "gray90"
    ) +
    ggplot2::theme(
      axis.text.x = ggplot2::element_text(
        size = 12, angle = 90, hjust = 1, vjust = 0.5
      ),
      panel.border = ggplot2::element_rect(
        color = "black", fill = NA, linewidth = 1
      )
    )
  if (forecast != 12) {
    plt_ls[[plt_name]] <- plt_ls[[plt_name]] +
      ggplot2::theme(
        strip.text.y = ggplot2::element_blank(),
        strip.background.y = ggplot2::element_blank()
      )
  }
}

plt <- patchwork::wrap_plots(
  plt_ls, nrow = 1, ncol = 3, byrow = FALSE, guides = "collect"
) +
  patchwork::plot_layout(axis_titles = "collect")
vthemes::subchunkify(
  plt, i = subchunk_idx, add_class = panel_class,
  fig_width = fig_width * 1.75, fig_height = fig_height,
  caption = "'Summary of the feature importance rankings from different survival models (x-axis). Each tile represents the rank of a variable, according to its mean importance from 50 random training-validation-test splits. Results are shown for different forecasting periods (columns).'"
)
subchunk_idx <- subchunk_idx + 1
```

# Bibliography

<div class="panel panel-default padded-panel">
<div id="refs"></div>
</div>